# H3 Hex Coverage Tool — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a Next.js web app where a user uploads a KML file and instantly sees an interactive map with H3 hex counts at resolutions 6, 7, and 8, deployable to Vercel.

**Architecture:** Pure-frontend Next.js (App Router, static export). KML is parsed client-side with `@tmcw/togeojson`, H3 cells computed with `h3-js`, and the map rendered with `react-leaflet`. No backend or API routes.

**Tech Stack:** Next.js 14, TypeScript, Tailwind CSS, h3-js, react-leaflet, @tmcw/togeojson

---

### Task 1: Initialize Next.js project

**Files:**
- Create: `package.json`, `tsconfig.json`, `next.config.js`, `tailwind.config.ts`, `postcss.config.js`

**Step 1: Scaffold the project**

```bash
cd /Users/praksha.chaudhary/projects/h3-hex-tool
npx create-next-app@latest . --typescript --tailwind --eslint --app --no-src-dir --import-alias "@/*"
```

When prompted, accept all defaults.

**Step 2: Verify it runs**

```bash
npm run dev
```

Open http://localhost:3000. Expected: Next.js default page.

**Step 3: Install domain dependencies**

```bash
npm install h3-js @tmcw/togeojson react-leaflet leaflet
npm install -D @types/leaflet
```

**Step 4: Configure static export in `next.config.js`**

Replace entire file with:

```js
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export',
  images: { unoptimized: true },
}
module.exports = nextConfig
```

**Step 5: Commit**

```bash
git init
git add .
git commit -m "feat: scaffold Next.js project with dependencies"
```

---

### Task 2: KML parser utility

**Files:**
- Create: `lib/kml-parser.ts`

**Purpose:** Extract polygons (name + coordinate rings) from a KML file string.

**Step 1: Create `lib/kml-parser.ts`**

```ts
export interface KmlPolygon {
  name: string
  // Outer ring: array of [lat, lng] pairs (H3 convention)
  coords: [number, number][]
}

export function parseKml(kmlText: string): KmlPolygon[] {
  const parser = new DOMParser()
  const doc = parser.parseFromString(kmlText, 'application/xml')
  const placemarks = Array.from(doc.querySelectorAll('Placemark'))
  const results: KmlPolygon[] = []

  for (const pm of placemarks) {
    const coordEl = pm.querySelector('Polygon outerBoundaryIs LinearRing coordinates')
    if (!coordEl) continue
    const name = pm.querySelector('name')?.textContent?.trim() ?? 'Unnamed'
    const raw = coordEl.textContent?.trim() ?? ''
    const coords: [number, number][] = raw
      .split(/\s+/)
      .filter(Boolean)
      .map((triplet) => {
        const [lng, lat] = triplet.split(',').map(Number)
        return [lat, lng] // H3 expects [lat, lng]
      })
    if (coords.length > 2) results.push({ name, coords })
  }

  return results
}
```

**Step 2: Verify manually**
Open the browser console later and call `parseKml()` with the sample KML to confirm 2 polygons are returned.

**Step 3: Commit**

```bash
git add lib/kml-parser.ts
git commit -m "feat: add KML polygon parser"
```

---

### Task 3: H3 computation utility

**Files:**
- Create: `lib/h3-utils.ts`

**Purpose:** Given a polygon's coordinate ring and a resolution, return all H3 cell IDs covering it, and convert cells to GeoJSON for Leaflet rendering.

**Step 1: Create `lib/h3-utils.ts`**

```ts
import { latLngToCell, cellToBoundary, polygonToCells } from 'h3-js'

export const RESOLUTIONS = [6, 7, 8] as const
export type Resolution = (typeof RESOLUTIONS)[number]

// Approx average hex area in km² per resolution (from H3 docs)
export const RES_AREA: Record<Resolution, string> = {
  6: '~36 km²',
  7: '~5.2 km²',
  8: '~0.74 km²',
}

export function getHexCells(
  coords: [number, number][],
  resolution: Resolution
): string[] {
  // polygonToCells expects [[lat, lng], ...] — matches our convention
  return polygonToCells(coords, resolution, true) // true = geo containment
}

export function cellsToGeoJson(cells: string[]) {
  return {
    type: 'FeatureCollection' as const,
    features: cells.map((cell) => {
      const boundary = cellToBoundary(cell) // returns [[lat,lng],...]
      const coords = [...boundary, boundary[0]].map(([lat, lng]) => [lng, lat]) // GeoJSON is [lng,lat]
      return {
        type: 'Feature' as const,
        geometry: { type: 'Polygon' as const, coordinates: [coords] },
        properties: { cell },
      }
    }),
  }
}
```

**Step 2: Commit**

```bash
git add lib/h3-utils.ts
git commit -m "feat: add H3 cell computation and GeoJSON conversion"
```

---

### Task 4: Upload zone component

**Files:**
- Create: `components/UploadZone.tsx`

**Purpose:** Drag-and-drop + click-to-browse KML file input. Calls `onLoad(kmlText)` when file is ready.

**Step 1: Create `components/UploadZone.tsx`**

```tsx
'use client'
import { useCallback, useState } from 'react'

interface Props {
  onLoad: (kmlText: string) => void
}

export default function UploadZone({ onLoad }: Props) {
  const [dragging, setDragging] = useState(false)

  const handleFile = useCallback(
    (file: File) => {
      const reader = new FileReader()
      reader.onload = (e) => onLoad(e.target?.result as string)
      reader.readAsText(file)
    },
    [onLoad]
  )

  const onDrop = useCallback(
    (e: React.DragEvent) => {
      e.preventDefault()
      setDragging(false)
      const file = e.dataTransfer.files[0]
      if (file?.name.endsWith('.kml')) handleFile(file)
    },
    [handleFile]
  )

  return (
    <div
      onDrop={onDrop}
      onDragOver={(e) => { e.preventDefault(); setDragging(true) }}
      onDragLeave={() => setDragging(false)}
      className={`flex flex-col items-center justify-center border-2 border-dashed rounded-xl p-8 cursor-pointer transition-colors
        ${dragging ? 'border-blue-500 bg-blue-50' : 'border-gray-300 bg-white hover:border-blue-400'}`}
      onClick={() => document.getElementById('kml-input')?.click()}
    >
      <svg className="w-10 h-10 text-gray-400 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5}
          d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
      </svg>
      <p className="text-gray-600 font-medium">Drop your KML file here</p>
      <p className="text-gray-400 text-sm mt-1">or click to browse</p>
      <input
        id="kml-input"
        type="file"
        accept=".kml"
        className="hidden"
        onChange={(e) => e.target.files?.[0] && handleFile(e.target.files[0])}
      />
    </div>
  )
}
```

**Step 2: Commit**

```bash
git add components/UploadZone.tsx
git commit -m "feat: add KML drag-and-drop upload zone component"
```

---

### Task 5: Summary table component

**Files:**
- Create: `components/SummaryTable.tsx`

**Purpose:** Show polygon name × resolution hex count table + resolution reference guide.

**Step 1: Create `components/SummaryTable.tsx`**

```tsx
import { KmlPolygon } from '@/lib/kml-parser'
import { RESOLUTIONS, RES_AREA, Resolution } from '@/lib/h3-utils'

interface Props {
  polygons: KmlPolygon[]
  counts: Record<string, Record<Resolution, number>>
  activeRes: Resolution
  onResChange: (r: Resolution) => void
}

const RES_COLOR: Record<Resolution, string> = {
  6: 'bg-green-500',
  7: 'bg-orange-400',
  8: 'bg-purple-500',
}

export default function SummaryTable({ polygons, counts, activeRes, onResChange }: Props) {
  return (
    <div className="bg-white rounded-xl shadow p-4 flex flex-col gap-4">
      <h2 className="font-semibold text-gray-800 text-sm uppercase tracking-wide">H3 Hex Coverage</h2>

      {/* Resolution toggle */}
      <div className="flex gap-2">
        {RESOLUTIONS.map((r) => (
          <button
            key={r}
            onClick={() => onResChange(r)}
            className={`flex-1 py-1.5 rounded-lg text-sm font-medium transition-colors
              ${activeRes === r ? `${RES_COLOR[r]} text-white` : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}
          >
            Res {r}
          </button>
        ))}
      </div>

      {/* Counts table */}
      <table className="w-full text-sm border-collapse">
        <thead>
          <tr className="bg-gray-50">
            <th className="text-left py-2 px-2 text-gray-500 font-medium">Polygon</th>
            {RESOLUTIONS.map((r) => (
              <th key={r} className="text-right py-2 px-2 text-gray-500 font-medium">Res {r}</th>
            ))}
          </tr>
        </thead>
        <tbody>
          {polygons.map((p) => (
            <tr key={p.name} className="border-t border-gray-100">
              <td className="py-2 px-2 text-gray-700 max-w-[120px] truncate" title={p.name}>{p.name}</td>
              {RESOLUTIONS.map((r) => (
                <td
                  key={r}
                  className={`text-right py-2 px-2 font-mono font-medium
                    ${activeRes === r ? 'text-gray-900' : 'text-gray-400'}`}
                >
                  {counts[p.name]?.[r]?.toLocaleString() ?? '—'}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>

      {/* Reference guide */}
      <div className="border-t pt-3">
        <p className="text-xs text-gray-500 font-medium mb-1">Hex size reference</p>
        {RESOLUTIONS.map((r) => (
          <div key={r} className="flex items-center gap-2 text-xs text-gray-500">
            <span className={`w-2 h-2 rounded-full ${RES_COLOR[r]}`} />
            <span>Res {r}: {RES_AREA[r]} per hex</span>
          </div>
        ))}
      </div>
    </div>
  )
}
```

**Step 2: Commit**

```bash
git add components/SummaryTable.tsx
git commit -m "feat: add resolution summary table component"
```

---

### Task 6: Interactive map component

**Files:**
- Create: `components/HexMap.tsx`

**Purpose:** Leaflet map showing polygon boundaries + H3 hex layer for the active resolution. Must be dynamically imported (no SSR) since Leaflet requires `window`.

**Step 1: Create `components/HexMap.tsx`**

```tsx
'use client'
import { useEffect, useRef } from 'react'
import { MapContainer, TileLayer, GeoJSON, Tooltip, useMap } from 'react-leaflet'
import L from 'leaflet'
import 'leaflet/dist/leaflet.css'
import { KmlPolygon } from '@/lib/kml-parser'
import { cellsToGeoJson, getHexCells, Resolution } from '@/lib/h3-utils'

// Fix leaflet default marker icon path issue in Next.js
delete (L.Icon.Default.prototype as any)._getIconUrl
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',
  iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
})

const POLY_COLORS = ['#1a73e8', '#e53935', '#0d9488', '#f59e0b']
const RES_HEX_COLOR: Record<Resolution, string> = { 6: '#2ecc71', 7: '#f39c12', 8: '#8b5cf6' }

interface Props {
  polygons: KmlPolygon[]
  activeRes: Resolution
}

function FitBounds({ polygons }: { polygons: KmlPolygon[] }) {
  const map = useMap()
  useEffect(() => {
    if (!polygons.length) return
    const all = polygons.flatMap((p) => p.coords.map(([lat, lng]) => [lat, lng] as [number, number]))
    map.fitBounds(all)
  }, [polygons, map])
  return null
}

export default function HexMap({ polygons, activeRes }: Props) {
  const hexColor = RES_HEX_COLOR[activeRes]

  return (
    <MapContainer
      center={[12.97, 77.59]}
      zoom={7}
      className="w-full h-full rounded-xl"
      preferCanvas
    >
      <TileLayer
        url="https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png"
        attribution='&copy; <a href="https://carto.com">CARTO</a>'
      />
      <FitBounds polygons={polygons} />

      {/* Polygon outlines */}
      {polygons.map((p, i) => {
        const color = POLY_COLORS[i % POLY_COLORS.length]
        const geoJson = {
          type: 'Feature' as const,
          geometry: {
            type: 'Polygon' as const,
            coordinates: [p.coords.map(([lat, lng]) => [lng, lat])],
          },
          properties: { name: p.name },
        }
        return (
          <GeoJSON
            key={`poly-${p.name}`}
            data={geoJson}
            style={{ color, weight: 2.5, fillOpacity: 0.07 }}
          >
            <Tooltip permanent direction="center" className="font-medium text-xs">
              {p.name}
            </Tooltip>
          </GeoJSON>
        )
      })}

      {/* H3 hex layer for active resolution */}
      {polygons.map((p) => {
        // Skip res 8 for large polygons (>70k cells) to prevent browser freeze
        const cells = getHexCells(p.coords, activeRes)
        if (activeRes === 8 && cells.length > 70000) return null
        const geoJson = cellsToGeoJson(cells)
        return (
          <GeoJSON
            key={`hex-${p.name}-${activeRes}`}
            data={geoJson as any}
            style={{
              color: hexColor,
              weight: activeRes === 6 ? 1 : 0.5,
              fillColor: hexColor,
              fillOpacity: activeRes === 6 ? 0.3 : 0.2,
            }}
          />
        )
      })}
    </MapContainer>
  )
}
```

**Step 2: Commit**

```bash
git add components/HexMap.tsx
git commit -m "feat: add interactive Leaflet H3 hex map component"
```

---

### Task 7: Main page — wire everything together

**Files:**
- Modify: `app/page.tsx`
- Modify: `app/layout.tsx`
- Modify: `app/globals.css`

**Step 1: Update `app/globals.css`** — replace body with:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

html, body { height: 100%; }
```

**Step 2: Update `app/layout.tsx`**

```tsx
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'H3 Hex Coverage Tool',
  description: 'Upload a KML boundary and see H3 hex coverage at resolutions 6, 7, and 8',
}

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  )
}
```

**Step 3: Replace `app/page.tsx`**

```tsx
'use client'
import dynamic from 'next/dynamic'
import { useCallback, useMemo, useState } from 'react'
import UploadZone from '@/components/UploadZone'
import SummaryTable from '@/components/SummaryTable'
import { parseKml, KmlPolygon } from '@/lib/kml-parser'
import { getHexCells, Resolution, RESOLUTIONS } from '@/lib/h3-utils'

// Leaflet must not be server-side rendered
const HexMap = dynamic(() => import('@/components/HexMap'), { ssr: false })

export default function Home() {
  const [polygons, setPolygons] = useState<KmlPolygon[]>([])
  const [activeRes, setActiveRes] = useState<Resolution>(7)
  const [fileName, setFileName] = useState<string>('')

  const handleKml = useCallback((kmlText: string, name?: string) => {
    const parsed = parseKml(kmlText)
    setPolygons(parsed)
    if (name) setFileName(name)
  }, [])

  // Pre-compute counts for all polygons × all resolutions
  const counts = useMemo(() => {
    const result: Record<string, Record<Resolution, number>> = {}
    for (const p of polygons) {
      result[p.name] = {} as Record<Resolution, number>
      for (const r of RESOLUTIONS) {
        result[p.name][r] = getHexCells(p.coords, r).length
      }
    }
    return result
  }, [polygons])

  return (
    <main className="min-h-screen bg-gray-50 flex flex-col">
      {/* Header */}
      <header className="bg-white border-b px-6 py-3 flex items-center gap-3">
        <div className="w-7 h-7 bg-blue-600 rounded-lg flex items-center justify-center">
          <svg className="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
              d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
          </svg>
        </div>
        <h1 className="text-gray-900 font-semibold text-lg">H3 Hex Coverage Tool</h1>
        {fileName && (
          <span className="ml-2 text-sm text-gray-400 bg-gray-100 px-2 py-0.5 rounded">{fileName}</span>
        )}
      </header>

      {/* Upload — shown only when no polygons loaded */}
      {polygons.length === 0 && (
        <div className="flex-1 flex items-center justify-center p-8">
          <div className="w-full max-w-md">
            <UploadZone
              onLoad={(text) => {
                const input = document.getElementById('kml-input') as HTMLInputElement
                handleKml(text, input?.files?.[0]?.name)
              }}
            />
          </div>
        </div>
      )}

      {/* Map + sidebar — shown after upload */}
      {polygons.length > 0 && (
        <div className="flex-1 flex gap-4 p-4 min-h-0" style={{ height: 'calc(100vh - 57px)' }}>
          {/* Map */}
          <div className="flex-1 min-h-0">
            <HexMap polygons={polygons} activeRes={activeRes} />
          </div>

          {/* Sidebar */}
          <div className="w-72 flex flex-col gap-3">
            <SummaryTable
              polygons={polygons}
              counts={counts}
              activeRes={activeRes}
              onResChange={setActiveRes}
            />
            <button
              onClick={() => { setPolygons([]); setFileName('') }}
              className="text-sm text-gray-400 hover:text-gray-600 underline text-center"
            >
              Upload a different file
            </button>
          </div>
        </div>
      )}
    </main>
  )
}
```

**Step 4: Run and verify in browser**

```bash
npm run dev
```

1. Open http://localhost:3000
2. Upload the Bangalore KML file from `~/Downloads/`
3. Confirm the map shows both polygons
4. Confirm layer toggles (Res 6 / 7 / 8) work
5. Confirm summary table shows correct counts

**Step 5: Commit**

```bash
git add app/
git commit -m "feat: wire up main page with upload, map, and summary"
```

---

### Task 8: Deploy to Vercel

**Files:**
- Create: `.gitignore`

**Step 1: Create `.gitignore`** (if not already created by Next.js scaffold):

```
node_modules/
.next/
out/
.env.local
```

**Step 2: Create GitHub repo and push**

```bash
gh repo create h3-hex-tool --public --source=. --remote=origin --push
```

(If `gh` is not available: create repo manually on github.com, then `git remote add origin <url> && git push -u origin main`)

**Step 3: Link and deploy to Vercel**

```bash
vercel login
vercel --cwd /Users/praksha.chaudhary/projects/h3-hex-tool
```

When prompted:
- **Set up and deploy?** → Y
- **Which scope?** → `prakshachaudharys-projects`
- **Link to existing project?** → N (new project)
- **Project name?** → `h3-hex-tool`
- **Directory?** → `.` (current)
- **Auto-detected Next.js** → confirm defaults

**Step 4: Verify deployment**

Vercel will print a URL (e.g. `https://h3-hex-tool.vercel.app`). Open it and upload the Bangalore KML to confirm it works.

**Step 5: Set up automatic deploys (optional)**

Future pushes to `main` will auto-deploy via the Vercel GitHub integration that was set up above.

---

## Summary

| Task | What it builds |
|------|---------------|
| 1 | Next.js scaffold + dependencies |
| 2 | KML parser utility |
| 3 | H3 hex computation + GeoJSON conversion |
| 4 | Drag-and-drop file upload component |
| 5 | Resolution summary table |
| 6 | Interactive Leaflet map with hex overlay |
| 7 | Main page wiring everything together |
| 8 | GitHub + Vercel deployment |
